# distutils: language=c++
# cython: language_level=3
# cython: binding=True
# NOTE: THIS FILE HAS BEEN GENERATED FROM A TEMPLATE
"""Functions wrapping stan::services functions.

The functions in this module are all thin wrappers of stan::services function.
The functions lack documentation because they are all essentially the same.
With minor exceptions, the signature of each function is identical to the
signature of the function in stan::services with the same name. The differences
between the two functions include:

- var_context variables are passed via an array_var_context_capsule PyCapsule.
- output of all writers is added to a single boost::spsc_queue, passed via a PyCapsule.

The template version of this file has a single string.Template placeholder
(``cpp_filename`` surrounded by curly brackets) which is replaced with the
filename of a C++ header file generated by Stan.

This Cython file has `binding=True` in order to allow the signatures of
functions defined here to be inspected.
"""
import httpstan.stan

cimport cpython
cimport cython.operator.dereference as deref
from libcpp.string cimport string

cimport httpstan.boost as boost
cimport httpstan.stan as stan


cdef extern from "${cpp_filename}" nogil:
    cdef cppclass stan_model:
        stan_model(stan.var_context& var_context) except +


def hmc_nuts_diag_e_wrapper(object array_var_context_capsule, object queue_capsule,
                             int random_seed, int chain, double init_radius,
                             int num_warmup, int num_samples):
    cdef int return_code
    cdef stan.array_var_context * var_context_ptr = <stan.array_var_context*> cpython.PyCapsule_GetPointer(array_var_context_capsule, b'array_var_context')
    cdef boost.spsc_queue[string] * queue_ptr = <boost.spsc_queue[string] *> cpython.PyCapsule_GetPointer(queue_capsule, b'spsc_queue')
    cdef stan.var_context * init_var_context = new stan.empty_var_context()
    cdef stan_model * model = new stan_model(deref(var_context_ptr))
    cdef stan.interrupt interrupt
    cdef stan.logger * logger = new stan.queue_logger(queue_ptr, b'logger:')
    cdef stan.writer * init_writer = new stan.queue_writer(queue_ptr, b'init_writer:')
    cdef stan.writer * sample_writer = new stan.queue_writer(queue_ptr, b'sample_writer:')
    cdef stan.writer * diagnostic_writer = new stan.queue_writer(queue_ptr, b'diagnostic_writer:')
    with nogil:
        return_code = stan.hmc_nuts_diag_e(deref(model), deref(init_var_context), random_seed, chain, init_radius,
                                            num_warmup, num_samples,
                                            1,    # num_thin
                                            0,    # save_warmup
                                            10,   # refresh
                                            1.0,  # stepsize
                                            0.0,  # stepsize_jitter
                                            10,   # max_depth
                                            interrupt,
                                            deref(logger),
                                            deref(init_writer),
                                            deref(sample_writer),
                                            deref(diagnostic_writer))
    del model
    del init_var_context
    del logger
    del init_writer
    del diagnostic_writer
    return return_code


def hmc_nuts_diag_e_adapt_wrapper(object array_var_context_capsule, object queue_capsule,
                                   int random_seed, int chain, double init_radius,
                                   int num_warmup, int num_samples):
    cdef int return_code
    cdef stan.array_var_context * var_context_ptr = <stan.array_var_context*> cpython.PyCapsule_GetPointer(array_var_context_capsule, b'array_var_context')
    cdef boost.spsc_queue[string] * queue_ptr = <boost.spsc_queue[string] *> cpython.PyCapsule_GetPointer(queue_capsule, b'spsc_queue')
    cdef stan.var_context * init_var_context = new stan.empty_var_context()
    cdef stan_model * model = new stan_model(deref(var_context_ptr))
    cdef stan.interrupt interrupt
    cdef stan.logger * logger = new stan.queue_logger(queue_ptr, b'logger:')
    cdef stan.writer * init_writer = new stan.queue_writer(queue_ptr, b'init_writer:')
    cdef stan.writer * sample_writer = new stan.queue_writer(queue_ptr, b'sample_writer:')
    cdef stan.writer * diagnostic_writer = new stan.queue_writer(queue_ptr, b'diagnostic_writer:')
    with nogil:
        return_code = stan.hmc_nuts_diag_e_adapt(deref(model), deref(init_var_context), random_seed, chain, init_radius,
                                                  num_warmup, num_samples,
                                                  1,    # num_thin
                                                  0,    # save_warmup
                                                  10,   # refresh
                                                  1.0,  # stepsize
                                                  0.0,  # stepsize_jitter
                                                  10,   # max_depth
                                                  0.8,  # * @param[in] delta adaptation target acceptance statistic
                                                  0.05, # * @param[in] gamma adaptation regularization scale
                                                  0.75, # * @param[in] kappa adaptation relaxation exponent
                                                  10,   # * @param[in] t0 adaptation iteration offset
                                                  75,   # * @param[in] init_buffer width of initial fast adaptation interval
                                                  50,   # * @param[in] term_buffer width of final fast adaptation interval
                                                  25,   # * @param[in] window initial width of slow adaptation interval
                                                  interrupt,
                                                  deref(logger),
                                                  deref(init_writer),
                                                  deref(sample_writer),
                                                  deref(diagnostic_writer))
    del model
    del init_var_context
    del logger
    del init_writer
    del diagnostic_writer
    return return_code
